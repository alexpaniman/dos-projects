* Вступление

Стремительное развитие аппаратного и программного обеспечения, именуемое "Компьютерной революцией", наградило людей невиданные ранее возможностями: от смартфонов способных помещаться в карман брюк и соединенные беспроводной технологией с большинством других девайсов по всему миру до ноутбуков, помещающихся в рюкзак, чей графический процессор способен отрисовать настолько реалистичный лес в реальном времени, что мало кто сможет его от такового отличить.

В процессе бурного развития мало кто, если вообще кто-либо, уже может вспомнить все этапы и в полной мере их осознать: как огромные ЭВМ с принтерами в качестве текстовых консолей получили в начале экранный терминал с текстовым графическим процессором, а затем и с полноценным, способным отображать произвольную сложную графику; как настройка внешних устройств в начале происходила с помощью ручного согласования соответствующих прерываний, а потом стала автоматической; как появились первые персональные компьютеры и как стремительный рост объема ОЗУ превратил в один момент убедительное утверждение Билла Гейтса, что после увеличения объема памяти =IBM PC= в 10 раз, доводя её до ~640 Kb~, памяти уж точно хватит всем до смехотворного, когда 40 лет спустя программа "Калькулятор" на прямом наследнике системы =DOS= --- =Windows 11= занимает ~16 Mb~, что почти на два порядка больше чем вся доступная тогда память.

Улучшением всех численных параметров компьютерной аппаратуры дело не ограничилось и в новых системах появились сложные инструменты разработки, системы защиты от разного рода уязвимостей, ставшие особенно важными с подключением компьютеров к мировой сети интернет, они также упроситили разработку и сделали использование новых программ значительно менее рискованным занятием.

При этом не все новшества заменяли старые, скорее наоборт --- они постепенно наслаивались, пока не развились в то, что мы имеем на сегодняший день. Таким образом многие процессоры имеют все ту же архитектуру что ~Intel 8086~ сорокалетней давности --- совместимый набор команд, и слегка расширенный набор регистров. Они запускаются в том же режиме работы, что и тогда, "реальном", хоть и быстро его покидают. Устройства все также используют прерывания для взаимодействия с системой, просто немного по-другому. Принципы заложенные ещё во времена фон Неймана, Тьюринга, Дейкстры и других знаменитых деятелей пережили своих отцов и по-прежнему видны в каждом устройстве.

Студентам изучающим инженерию компьютеров, вроде меня, теперь можно только посочувствовать --- ведь изучать нужно не только несопоставимо большие объемы информации в сравнении с тем что было известно и применялось всего пару десятков лет назад, так ещё и делать это желательно мгновенно, все и сразу --- иначе, не обладая полной картиной, за этими системами просто невозможно наблюдать. Взять к примеру чтение информации напрямую с клавиатуры --- ранее простейшая задача теперь требует умения обходить огромные баррикады из систем безопасности, понимание нетривиальных процессов загрузки современной ОС, вместе с умением пользоваться её системами для реализации собственных драйверов.

Так и родился этот проект --- желание поработать напрямую с внешними устройствами без необходимости годы собирать по крупицам знания о всем мноогообразии промежуточных систем задача вполне реальная если "обратить время вспять" и воспользоваться современными средствами эмуляции системы =DOS=.


* Проектирование системы

Проект хотелось подобрать таким образом чтобы одновременно охватить широкий спектр вещей которые значительно усложнились со временем, при этом сохранить его целостность и общую полезность.

Решение было принято в пользу программы резидентной программы, в реальном времени считывающую и отображающую значения аппаратных регистров в дальнейших разделах будут рассмотрены теоретические и практические подходы к реализации таковой.


** Платформа

Низкоуровневые вещи, которые утилита собирается делать и которые, при этом, очень сложны для выполнения в современных операционных системах:

1. Перехват прерываний. В современных операционных системах никакие программы за пределами 0 кольца привелегий не имеют права лезть в таблицу прерываний, которая удивительным образом, начиная с 80х находится все по тем же адресам.

2. Чтение данных из аппаратных регистров все ещё возможно, но, бесполезно, ведь перед тем как планировщик задач вызовет нашу user-space программу вся информация записанная в регистры программой запущенной перед нами будет сохранена для дальнейшей загрузки и почищена ради безопасности. А значит и способа проверить показывает ли наша программа разумные результаты не будет.

3. Рисование меню с результатами тоже очень сложно, ведь текстовые видеокарты читающие напрямую с определенных адресов и рисующие на экране запрограммированые глифы уже давно нет в потребительских компьютерах. Вместо этого мы имеем невероятно мощную, но сложную в управлении видеокарту, интерфейс с которой завернут в графические API, дисплей сервера и прочие слои абстракции.

Эти системы очень полезны и удобны для современного разработчика и пользователя.

Но в тоже самое время значительно усложняют разработку подобного <<небезопасного>> инструмента -- потребуется реализовать драйвер, который запуститься в 0 кольце привелегий -- уже та ещё задачка даже для драйвера который будет просто успешно запускаться с системой: ничему не мешать и ничего больше не делать. Другие пункты приближают проект к отметке <<невозможно>>.


К счастью, многие из этих вещей можно потрогать напрямую в =DOS=, эмулятор которой можно без проблем установить на современную систему. В частности при разработке этого проекта будет использоваться =Dosbox=.

** Обработка нажатия клавиш

При каждом нажатии на кнопку клавиатуры, контроллер клавиатуры посылает по шине сообщение, приводящее к прерыванию текущей задачи процессора и вызову к специального кода-обработчика.

В =dos= таким прерыванием является =09H=, чтобы его подменить достаточно в interrupt vector table (IVT), которая находится в самом начале виртуальной памяти, в 0H сегменте.

Каждый элемент таблицы =IVT= представляет собой набор из =CS:IP= (в обратном порядке в связи с little-endian), занимающий 4 байта каждый. Такой набор при вызове того или иного прерывания используется для =long jump= к соответствующему обработчику.


** Интроспекция работы других программ

Мы хотим определять значения регистров во время работы других программ. Добиться такого сложно --- с самого начала возникают вопросы:

1. Как мы можем следить за другой программой, если в один момент времени =dos= позволяет запустить лишь одну? Разве наблюдение не подразумевается присутствие двух?

2. Как отслеживать значения регистров, если единственный инструмент для операций наблюдения --- сами эти регистры?

На помощь опять приходят системные прерывания: в процессор встроен асинхронный таймер реального времени, которые прерывает выполнение процессор вне зависимости от внешних факторов.

Прерывание происходит через равные промежутки времени, на =dos= и процессорах, вроде =intel 80286=, под который мы разрабатываем нашу систему, прерывание происходит каждые =55ms=, что не очень много, но для того чтобы увидеть какие-то правдоподобные результаты -- хватит. Естественно задача отслеживать все изменения --- невыполнима, ведь для отслеживания нужно ненулевое количество действий с регистрами, а это в свою очередь ведет к изменениям которые тоже нужно отслеживать --- чувствуется скользкая тропинка. Поэтому в данном проекте будем довольствоваться периодическим снятием показаний.

Что касается второго вопроса, то достаточно сохранить регистры с помощью команды =push=, которая меняет единственный регистр --- =sp=, причем это изменение -- просто увелчение на 2, такое легко предсказать и высчитать исходное значение =sp=.


* Программная реализация

** Выбор типа исполняемого файла

=DOS= поддерживает два типа исполняемых файлов: =.com= и =.exe=. И хоть последний намного более продвинутый: например, он позволяет начинать программу с произвольного адреса, а не только с =100H=, как в =.com= файлах он все же значительно отличается от современных и достаточно сложен в освоение в сравнении с примитивным =.com=, почему и был выбран последний.

** Перехват аппаратных прерываний

Мы определились что прерывания играют значительную роль в данной программе. Осталось разобраться как их корректно перехватывать.

Как уже было упомянуто в самом начале адресного пространства находится =IVT= (Interrupt Vector Table) --- таблица, в которой для каждого прерывания описано место нахождения кода-обработчика, выглядит это так:

[[file:imgs/ivt.svg]]

Самый просто способ его осуществить -- подменить нужную запись в таблице прерываний. Тогда, правда, сразу возникает закономерная проблема --- система перестает реагировать на какие-либо нажатия за исключением того, которое обрабатывает новый обработчик. Это и неудивительно, ведь старый обработчик был затерт и больше не получает никакой информации.

Но как же быть, если мы хотим частично модифицировать поведение прерывания, но не заменять его полностью? Простое решение --- после того как мы завершили собственную обработку, достаточно передавать управление старому обработчику.

Таким образом обработчики образуют односвязный список:

[[file:imgs/list.svg]]

Причем, если внезапно какой-то обработчик захочет прервать цепочку, такая возможность у него тоже есть --- достаточно не вызывать следующий обработчик в списке. Это полезно, например, когда мы обнаружили определенное сочетание клавиш, которое обработала наша программа, а её видимость для других обработчиков приведут только к нежелательным действиям параллельным с нашим.

[[file:imgs/iret.svg]]

Поскольку система перехватывания прерывания является очень важной и часто используемой, для удобства был реализован макрос, который автоматически регистрирует прерывания и оборачивает функцию-обработчик таким образом, чтобы она автоматически подчищала регистры, значения которых нужно сохранить, реализация этого макроса представлена на листинге на следующей странице.

[[file:imgs/hook.svg]]

Можно заметить интересный способ формирования списка: вместо того чтобы хранить в сегменте =data= указатель на местоположение обработчка, как подобная система была бы реализована в системе с работающей в защищенном режиме, при перехвате прерывания я редактирую код обработчика таким образом, чтобы в его конце оказался =jmp far= на нужный адрес. Для этого в листинге выше видно вручную написаный код команды, =dd 0EAH= и подготовленное место для будующего адреса, отмеченного меткой =@@previous_interrupt=.

Работой по интеграции сформированного обработчика занимается вспомогательная функция =intercept_interrupt=, её реализация представлена ниже:

[[file:imgs/intercept_interrupt.svg]]

Из интересного здесь смещение в нулевой сегмент памяти, а также аккуратное отключение аппаратных прерываний (посредством установки соответствующего флага командой =cli=), которая предупреждает ситуацию, когда асинхронный таймер (или другое аппаратное прерывание) происходит во время того как адрес её обработчика переписывается и тем самым приводит к вызову фактически случайного кода, и, вероятно, преводит систему к зависанию с единственным решением в виде аппаратной перезагрузки. Как только таблица успешно обновлена, флаг прерываний безопасно устанавливается обратно командой =sti=.


** Чтение данных и рисование рамки

Чтение значений регистров и рисование рамки с информацией происходит в обработчике прерывания по-таймеру, как было обсуждено раньше.

Отображение регистров на экране происходит путем непосредственной записи в видеопамять, организованную в виде подряд идущих двухбайтовых сочетаниях, где каждый первый байт представляет собой символ на экране, а каждый следующий бит набор цветов в формате:

[[file:imgs/colors.svg]]

Находится этот массив в самом начале видеосегмента (=0B800H=), изменения внесенные в эту область памяти видны на экране немедленно.

Сам код обработчика =08H= вполняющего обе задачи (чтени и отображение) текущей секции представлен в листинге ниже:

[[file:imgs/int08.svg]]

Реализация функций =draw_frame= и =print_registers_in_buffer= опущены по причине своей громоздкости, ниже представлены вырезки из документации описанием конвенции вызова, которой будет достаточно для понимания кода прерывания:

[[file:imgs/print-registers-in-buffer-docs.svg]]

Концептуально там происходит копирование строки с названием регистра из =data= сегмента программы и вызов функции конвертации двоичного числа в его шестнадцатеричное представление.

Функция рисования рамки вокруг вызвается после и обрамляет сформированный в текстовом буффере текст сообщения с регистрами, предварительно делая нужные рассчеты длины и местоположения элементов таблицы, а затем построчно выписывая элементы на экран:

[[file:imgs/draw-frame-docs.svg]]


** Завершение программы
Все системы готовыб осталось понять как нам завершить нашу программу, ведь как обычно не получится --- =dos= отчищает всю память отданную завершенным процессам и наши обработчики будут затерты.

Оказывается, на это случай у =dos= есть специальный сервис для этого: exit and stay resident, реализация удобного макроса использующего это систему представлена ниже:

[[file:imgs/resident.svg]]

Осталось запустить нашу программу, точка входа с помощью традиционного =jmp= перенесена вниз, чтобы разрешить удобное включение <<библиотек>> состоящих из файлов и макросов:

[[file:imgs/entry.svg]]


* Выводы

Реализовать задуманную систему удалось в полной мере, исходный код её доступен на =github=: https://github.com/alexpaniman/dos-projects/tree/master/resident. Для удобной сборки там размещен небольшой =make.bat= файл, воспользовавшись которым читатель самостоятельно может воспользоваться описанной системой.

Процесс реализации подобного проекта позволил мне, как студенту, значительно углубить знания базовых принципов и инструментов как старых, так и современных ОС. Реализация полноценных систем на ассемблере тоже дала положительный результат --- после такого удается писать более производительный код на высокоуравневых языках, ко всему обретенный опыт упрощает чтение ассемблера сгенерированного компиляторами, польза чего неоценима при работе с низкоуровневыми оптимизациями програм.

Что касается проекта, то есть ещё несколько очевидных улучшений, которые бы могли его ощутимо улучшить.

Одно из таких --- исправление недостатка в рисовании окна --- отсутствие двойной буфферизации. Эта методика позволила бы окну корректно исчезать даже когда подлежашее окно не перерисовывает его активно, что удобно, например, в =Volkov Commander=.

Также, можно немного cъекономить немногочисленную память системы затирая перед переходом в резидентное состояние ненужную часть программы. Ведь её, как уже шутливо писалось во введении, к сожалению, не хватает всем.

* Приложение: итоговый вид программы

Время проверять работоспособность реализованной программы.

На первый взгляд определить правельность работы программы сложно: можно увидеть, что меню появляется и перестает рисоваться соответственно на первое и второе нажатие нужной кнопки, можно увидеть мелькающие значения регистров и что рамочка выглядит верно, но вот понять правильные ли значения регистров пишутся в каждом из них --- более сложная задача.

Определить это наверняка можно с помощью такой вспомогательной программы:

[[file:imgs/regs.svg]]

Все что она делает --- устанавливает регистры в нужные значения, для дальнейшего наблюдения из меню резидента.

Программа представленная выше, правда, никогда не завершится. И так как многозадачности в =DOS= нет, то привести его обратно в рабочее состояние придется посредством перезапуска.

Это ограничение, однозначно, можно обойти, добавив в программу, к примеру, возможность выключение на нажатие отличной от используемой нами для меню клавиши, о принципах перехвата которой мы уже подробно говорили в секции про 

Второй, чуть более простой метод --- простой счетчик внутри программы был бы совсем прост в реализации, но, безусловно, менее удобным в использовании. Не смотря на все эти вполне справедливые идеи для для нашего эксперимента я посчитал такие улучшения избыточными.

Возвращаясь к тестированию с помощью вышеприведенной программы, хочу заметить, что все регистры в меню должны принять шестнадцатиричное значение =FFFF=, что мы и наблюдаем на прилодженном ниже скриншоте:

[[file:imgs/preview-in-dos.svg]]

Видно что изображение на картинке в точности совпадает с нашими ожиданиями. При этом важно заметить что некоторые флуктуации все-равно возможны, ведь асинхронные прерывания все ещё происходят и тоже используют регистры, записывая в них отличные значения. К счастью, отношение времени которое выполняются они к длительности периода активности основной программы настолько мало, что никаких мельканий значений на практике не встречается.

Для полноты проверки был проведен ещё ряд тестов с другими значения регистров, а тесты на правильность соответствия названия регистра и его значения, который легко обустроить, присвоив в тестирующей системе уникальные значения всем выводимым регистрам. Скриншоты соответствующих тестов опущены по причине их аналогичности представленному выше результату.






